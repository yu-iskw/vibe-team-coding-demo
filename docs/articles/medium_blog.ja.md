# プロンプトの先へ：マルチエージェント・オーケストレーションによるAIエンジニアリングのスケールアップ

**Vibe Kanban、ADR、そして特化型サブエージェントを活用し、「AI負債」を作らずにプロダクション・グレードのソフトウェアを構築する方法**

---

## 「一匹狼」モデルの限界：なぜ単独のAIエージェントは大規模開発で失敗するのか

AIによるコーディングのデモンストレーションの多くは、共通のパターンに従っています。開発者が1つのLLMに対して複雑なプロンプトを送り、LLMが数百行のコードを出力するというものです。それは魔法のように見えますが、プロジェクトをスケールさせようとすると、すぐに限界にぶつかります。

実際のエンジニアリングにおいて、このような「一匹狼」あるいは「カウボーイ・コーディング」のアプローチは、あらゆる開発チームが恐れる3つの大きな失敗を引き起こします。

1. **アーキテクチャの乖離 (Architectural Drift)**: グローバルな視点がないまま、AIがシステム全体と衝突する局所的な決定を下してしまいます。これはAIが生み出す「スパゲッティコード」の典型です。
2. **コンテキストの崩壊とドキュメント負債 (Context Collapse & Documentation Debt)**: コードベースが成長するにつれ、エージェントも人間も、過去の変更の「理由」を見失ってしまいます。これは「バス係数（Bus Factor）」を高めるリスクとなります。つまり、プロンプトを書いた人がいなくなれば、その知識も失われてしまうのです。
3. **可視性の欠如 (Visibility Blackout)**: プルリクエスト（PR）が届くまで、ステークホルダーはAIが実際に何をしているのか把握できません。もしAIが要件を誤解していた場合、何時間もの実行時間を無駄にすることになります。

これらを解決するために、私たちは単独のエージェントという枠を超えました。プロフェッショナルなエンジニアリング・ハイジーン（衛生的慣習）によって統治された、階層的なマルチエージェント・システム、**AI Swarm（AIの群れ）**を構築したのです。これは単なるコード作成ではなく、**「スケーラブルなプロジェクト管理」**そのものです。

---

## 1. 指揮統制（Command & Control）の階層構造：オーケストレーションと実行の分離

私たちのアプローチの根幹にあるのは、「より計画を、より少ないレビューを (Plan more, review less)」という信条です。ハイレベルな戦略に5分を費やすことで、後の数時間の修正を省くことができます。私たちはAIの役割を、**「戦略的オーケストレーション (Strategic Orchestration)」**と**「戦術的実行 (Tactical Execution)」**という2つの明確な役割に分割しています。

![アーキテクチャ図](./assets/architecture.png)

### vibe-orchestrator（戦略担当）

オーケストレーターはプロジェクトの「頭脳」であり、設計思想の守護者です。実装コードは書きません。その代わりに、以下のことを行います。

- **既存パターンのリサーチ**: 特化型の `explore` ツールを使用して、新しい機能がシステム全体に違和感なく馴染むことを保証します。
- **アーキテクチャ意思決定記録 (ADR) の起草**: 技術的な選択の根拠（Rationale）を文書化し、プロジェクトの記憶を刻みます。
- **MCP経由でのボード同期**: **Vibe Kanban MCPサーバー**を使用することで、オーケストレーターはプログラムによってタスクとサブタスクの階層をボード上に作成します。ここでは **「細粒度なタスク分解 (Granular Decomposition)」** を実践し、巨大な要件を、個別のエージェントが並行して処理可能な独立した作業単位へと分割します。

### vibe-worker（戦術担当）

ワーカーは「手」としての役割を担います。看板ボードから最小単位のチケット（タスク）を受け取ります。

- **Git Worktreeによる分離**: すべてのタスクの試行は、それぞれ独立した一時的な **Git Worktree（Gitワークツリー）** で実行されます。この分離された環境により、10以上のワーカーが同じリポジトリで干渉することなく並行して作業でき、衝突を防ぎます。
- **自動化されたハイジーン（セットアップ/クリーンアップ）**: ワーカーが開始する前に、**セットアップ・スクリプト**（例：`npm install`）が環境を準備します。完了時には、**クリーンアップ・スクリプト**（例：`npm run lint`）がワークスペースを清潔に保ちます。
- **リアルタイムの進捗報告**: 看板ボードに進捗を報告し、一行単位での作業を可視化します。

![Cursorによるエージェント・オーケストレーションの実演](./assets/cursor_screenshot.png)

上のスクリーンショットに見られるように、計画フェーズはCursor内で直接オーケストレートされます。`vibe-orchestrator`が要件を分析し、コードベースを探索した上で、包括的な実行計画を提案します。この戦略的な整合性により、実装が始まる前に人間が「何を作るか（What）」と「なぜ作るか（Why）」を検証できるようになります。

---

## 2. 神経回路：Vibe Kanbanとインタラクティブな検証

![Vibe Kanbanボードの全体像](./assets/vibe_kanban_screenshot.png)

検証済みの計画がMCPサーバー経由で同期されると、Vibe Kanbanボードに分解された並列実行可能なタスクが自動生成されます。スクリーンショットは、ハイレベルな意図がアクティブな実装の「群れ（Swarm）」へと変換される様子を示しています。複数の`vibe-worker`エージェントがこれらのチケットを並行して処理することで、アーキテクチャの境界を厳密に守りながら、開発サイクルを劇的に加速させます。

スケールの秘訣は、単に優れたプロンプトを書くことではなく、**タスク管理 (Task Management)** と **的確なフィードバック** にあります。Vibe Kanbanボードを「信頼できる唯一の情報源 (Source of Truth)」として使用することで、100%のオブザーバビリティ（可視性）を実現しています。

![タスク・ライフサイクル・シーケンス](./assets/lifecycle.png)

### 計画が先、コードは次 (Plan-First, Code-Second)

私たちのワークフローでは、チケットを「進行中 (In Progress)」に移す前に、必ずオーケストレーターが検証済みの計画を作成します。これには、戦略的なフェーズに特化した **Plan Mode** バリアントが活用されます。もしアプローチが失敗しても、エージェントは **再計画 (Re-plan)** を行い、壊れたソリューションをパッチするのではなく、より良いコンテキストで要約された新鮮なスタートを切ることができます。

### 細粒度なタスク分解：小さな「群れ」で巨大な問題を解く

AIエンジニアリングにおける最大のボトルネックの一つは、単一モデルの「コンテキスト・ウィンドウ」と推論能力の限界です。タスクが巨大すぎると、AIのロジックは破綻し始めます。私たちの解決策は **「細粒度なタスク分解 (Granular Decomposition)」** です。

オーケストレーターの最も重要な役割は、独立したロジックのブロックを特定し、巨大な要件を小さく噛み砕いたサブタスクに分割することです。これにより、以下のメリットが生まれます。

- **集中した推論**: 各サブエージェントは、隔離された特定の課題に集中できるため、ロジックエラーのリスクを劇的に低減できます。
- **並列による加速**: タスクが独立しているため、複数の `vibe-worker` エージェントを同時に起動できます。単独のエージェントなら4時間かかる機能も、8つのエージェントの「群れ（Swarm）」なら30分で完了します。
- **スケーラビリティ**: この「分割統治」戦略により、単一のLLMではメモリに保持しきれないような複雑なシステムの構築が可能になります。

### インタラクティブなフィードバックとプレビュー

**埋め込みプレビュー・ブラウザ**により、「これを試してみてくれますか？」という当て推量を排除しました。

- **コンポーネント・セレクション**: 「右上のボタン」といった曖昧な説明の代わりに、開発者はWeb Companionを使用してUIコンポーネントを直接選択できます。エージェントは正確なDOMセレクターとソースファイルの場所を受け取るため、UIの調整が決定論的になります。
- **アクションの承認**: 自律的な「YOLO」モードであっても、重要なアクションには人間の承認を求めることができ、スピードを犠牲にすることなく制御を維持できます。

---

## 3. コードとしてのエンジニアリング・ハイジーン：アーキテクチャの記憶を刻む

AIエージェントの質は、私たちが与えるガードレールによって決まります。私たちは特化型のエージェント・スキルと **タスク・タグ（@メンション）** を使用して、AIが生成したコードベースが長年にわたって保守可能であることを保証します。

![ハイジーン・フロー図](./assets/hygiene.png)

### ADRによる「アーキテクチャの記憶」の継承

データベースの選定や状態管理パターンの決定など、あらゆる重要な選択は `manage-adr` スキルを使用して文書化されます。これにより、将来のエージェント（あるいは人間）が、過去の重要な決定を誤って覆してしまう「AI健忘症」を防ぎます。

### 自動化されたステークホルダーへの報告 (Changelog)

私たちは、時に乱雑になりがちなgitの履歴だけに頼りません。`manage-changelog` スキル（Changieを使用）は、エージェントが完了したタスクごとに「変更フラグメント」を記録することを要求します。これにより、技術的な「ノイズ」を、ステークホルダーがすぐに読めるリリースノートへと自動的に変換します。技術的な「How（いかに作ったか）」とビジネス上の「What（何が変わったか）」のギャップを埋めるのです。

### タスク・タグによる実行の標準化

グローバルな **タスク・タグ（@メンション）** を使用することで、受入条件やレビュー・チェックリストなどの共通のエンジニアリング基準を、あらゆるタスクの説明に素早く挿入できます。これにより、すべてのエージェントが同じプロフェッショナルな基準に従うことが保証されます。

---

## 未来に向けて：「行を書く人」から「意図のディレクター」へ

AIエンジニアリングの真の目標は、開発者を置き換えることではなく、**「退屈な作業 (drudgery)」を置き換えること**です。特化型サブエージェントを構造化されたワークフローでオーケストレートすることで、AIを単なる「コーディング・アシスタント」から、対等な**「プロダクション・パートナー」**へと進化させます。

このエコシステムにおいて、人間の開発者の役割は進化しています。もはや構文やボイラープレートに振り回される「行を書く人」ではありません。あなたは**「意図のディレクター (Director of Intent)」**になろうとしています。ビジョンを定義し、結果を検証し、AIの群れを指揮するアーキテクトへと。

---

*実際のワークフローをご覧になりたいですか？私たちの [GitHub リポジトリ](https://github.com/vibe-team-coding-demo) をチェックし、私たちがどのようにこれらのエージェントの振る舞いを定義しているか、 `.cursor/rules` を探索してみてください。*
