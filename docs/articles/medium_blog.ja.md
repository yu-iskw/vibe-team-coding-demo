# プロンプトの先へ：マルチエージェント・オーケストレーションによるAIエンジニアリングのスケールアップ

**Vibe Kanban、ADR、そして特化型サブエージェントを活用し、「AI負債」を作らずにプロダクション・グレードのソフトウェアを構築する方法**

---

## 「一匹狼」モデルの限界：なぜ単独のAIエージェントは大規模開発で失敗するのか

AIによるコーディングのデモンストレーションの多くは、共通のパターンに従っています。開発者が1つのLLMに対して複雑なプロンプトを送り、LLMが数百行のコードを出力するというものです。それは魔法のように見えますが、プロジェクトをスケールさせようとすると、すぐに限界にぶつかります。

実際のエンジニアリングにおいて、このような「一匹狼」あるいは「カウボーイ・コーディング」のアプローチは、あらゆる開発チームが恐れる3つの大きな失敗を引き起こします。

1. **アーキテクチャの乖離 (Architectural Drift)**: グローバルな視点がないまま、AIがシステム全体と衝突する局所的な決定を下してしまいます。これはAIが生み出す「スパゲッティコード」の典型です。
2. **コンテキストの崩壊とドキュメント負債 (Context Collapse & Documentation Debt)**: コードベースが成長するにつれ、エージェントも人間も、過去の変更の「理由」を見失ってしまいます。これは「バス係数（Bus Factor）」を高めるリスクとなります。つまり、プロンプトを書いた人がいなくなれば、その知識も失われてしまうのです。
3. **可視性の欠如 (Visibility Blackout)**: プルリクエスト（PR）が届くまで、ステークホルダーはAIが実際に何をしているのか把握できません。もしAIが要件を誤解していた場合、何時間もの実行時間を無駄にすることになります。

これらを解決するために、私たちは単独のエージェントという枠を超えました。プロフェッショナルなエンジニアリング・ハイジーン（衛生的慣習）によって統治された、階層的なマルチエージェント・システム、**AI Swarm（AIの群れ）**を構築したのです。これは単なるコード作成ではなく、**「スケーラブルなプロジェクト管理」**そのものです。

---

## 1. 指揮統制（Command & Control）の階層構造：オーケストレーションと実行の分離

私たちののアプローチの根幹にあるのは、「より計画を、より少ないレビューを (Plan more, review less)」という信条です。ハイレベルな戦略に5分を費やすことで、後の数時間の修正を省くことができます。私たちはAIの役割を、**「戦略的オーケストレーション (Strategic Orchestration)」**と**「戦術的実行 (Tactical Execution)」**という2つの明確な役割に分割しています。

![アーキテクチャ図](./assets/architecture.png)

### vibe-orchestrator（戦略担当）

オーケストレーターはプロジェクトの「頭脳」であり、設計思想の守護者です。実装コードは書きません。その代わりに、以下のことを行います。

- **既存パターンのリサーチ**: 特化型の `explore` ツールを使用して、新しい機能がシステム全体に違和感なく馴染むことを保証します。
- **アーキテクチャ意思決定記録 (ADR) の起草**: 技術的な選択の根拠（Rationale）を文書化し、プロジェクトの記憶を刻みます。
- **MCP経由でのボード同期**: **Vibe Kanban MCPサーバー**を使用することで、オーケストレーターはプログラムによってタスクとサブタスクの階層をボード上に作成し、生の計画を追跡可能な作業単位へと変換します。

### vibe-worker（戦術担当）

ワーカーは「手」としての役割を担います。看板ボードから最小単位のチケット（タスク）を受け取ります。

- **Git Worktreeによる分離**: すべてのタスクの試行は、それぞれ独立した一時的な **Git Worktree（Gitワークツリー）** で実行されます。この分離された環境により、10以上のワーカーが同じリポジトリで干渉することなく並行して作業でき、衝突を防ぎます。
- **自動化されたハイジーン（セットアップ/クリーンアップ）**: ワーカーが開始する前に、**セットアップ・スクリプト**（例：`npm install`）が環境を準備します。完了時には、**クリーンアップ・スクリプト**（例：`npm run lint`）がワークスペースを清潔に保ちます。
- **リアルタイムの進捗報告**: 看板ボードに進捗を報告し、一行単位での作業を可視化します。

---

## 2. 神経回路：Vibe Kanbanとインタラクティブな検証

スケールの秘訣は、単に優れたプロンプトを書くことではなく、**タスク管理 (Task Management)** と **的確なフィードバック** にあります。Vibe Kanbanボードを「信頼できる唯一の情報源 (Source of Truth)」として使用することで、100%のオブザーバビリティ（可視性）を実現しています。

![タスク・ライフサイクル・シーケンス](./assets/lifecycle.png)

### 計画が先、コードは次 (Plan-First, Code-Second)

私たちのワークフローでは、チケットを「進行中 (In Progress)」に移す前に、必ずオーケストレーターが検証済みの計画を作成します。これには、戦略的なフェーズに特化した **Plan Mode** バリアントが活用されます。もしアプローチが失敗しても、エージェントは **再計画 (Re-plan)** を行い、壊れたソリューションをパッチするのではなく、より良いコンテキストで要約された新鮮なスタートを切ることができます。

### インタラクティブなフィードバックとプレビュー

**埋め込みプレビュー・ブラウザ**により、「これを試してみてくれますか？」という当て推量を排除しました。

- **コンポーネント・セレクション**: 「右上のボタン」といった曖昧な説明の代わりに、開発者はWeb Companionを使用してUIコンポーネントを直接選択できます。エージェントは正確なDOMセレクターとソースファイルの場所を受け取るため、UIの調整が決定論的になります。
- **アクションの承認**: 自律的な「YOLO」モードであっても、重要なアクションには人間の承認を求めることができ、スピードを犠牲にすることなく制御を維持できます。

---

## 3. コードとしてのエンジニアリング・ハイジーン：アーキテクチャの記憶を刻む

AIエージェントの質は、私たちが与えるガードレールによって決まります。私たちは特化型のエージェント・スキルと **タスク・タグ（@メンション）** を使用して、AIが生成したコードベースが長年にわたって保守可能であることを保証します。

![ハイジーン・フロー図](./assets/hygiene.png)

### ADRによる「アーキテクチャの記憶」の継承

データベースの選定や状態管理パターンの決定など、あらゆる重要な選択は `manage-adr` スキルを使用して文書化されます。これにより、将来のエージェント（あるいは人間）が、過去の重要な決定を誤って覆してしまう「AI健忘症」を防ぎます。

### タスク・タグによる実行の標準化

グローバルな **タスク・タグ（@メンション）** を使用することで、受入条件やレビュー・チェックリストなどの共通のエンジニアリング基準を、あらゆるタスクの説明に素早く挿入できます。これにより、すべてのエージェントが同じプロフェッショナルな基準に従うことが保証されます。

---

## 未来に向けて：「行を書く人」から「意図のディレクター」へ

AIエンジニアリングの真の目標は、開発者を置き換えることではなく、**「退屈な作業 (drudgery)」を置き換えること**です。特化型サブエージェントを構造化されたワークフローでオーケストレートすることで、AIを単なる「コーディング・アシスタント」から、対等な**「プロダクション・パートナー」**へと進化させます。

このエコシステムにおいて、人間の開発者の役割は進化しています。もはや構文やボイラープレートに振り回される「行を書く人」ではありません。あなたは**「意図のディレクター (Director of Intent)」**になろうとしています。ビジョンを定義し、結果を検証し、AIの群れを指揮するアーキテクトへと。

---

*実際のワークフローをご覧になりたいですか？私たちの [GitHub リポジトリ](https://github.com/vibe-team-coding-demo) をチェックし、私たちがどのようにこれらのエージェントの振る舞いを定義しているか、 `.cursor/rules` を探索してみてください。*
